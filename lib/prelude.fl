mod Prelude where

-- 1. The Core Choice Types (Equational Sums)

type Maybe a =
    | Just a
    | Nothing

type Result a e =
    | Ok a
    | Err e

-- 2. The Universal Comparison Trinity

type Ordering =
    | LT
    | EQ
    | GT

trait Eq a where
    equals : a, a -> Bool

trait Ord a where
    compare : a, a -> Ordering

-- 3. The Numeric Trinity

trait Num a where
    plus  : a, a -> a
    minus : a, a -> a
    times : a, a -> a

-- 4. Functional Structures (Functor, Monad)

trait Functor f where
    map : (a -> b), f a -> f b

trait Monad m where
    pure : a -> m a
    bind : m a, (a -> m b) -> m b

-- 5. Instances for Result (Equational Reasoning)

impl Functor (Result a e) where
    map f = 
        | Ok x  -> Ok (f x)
        | Err e -> Err e

impl Monad (Result a e) where
    pure x = Ok x
    bind =
        | Ok x, f  -> f x
        | Err e, _ -> Err e

-- 6. The Recursive Trinity (Lists)

type List a =
    | Nil
    | Cons (a, List a)

let head =
    | Nil         -> Nothing
    | Cons (x, _) -> Just x

let tail =
    | Nil          -> Nothing
    | Cons (_, xs) -> Just xs

let null =
    | Nil -> True
    | _   -> False

let length =
    | Nil          -> 0
    | Cons (_, xs) -> plus (1, length xs)

let foldr f z =
    | Nil          -> z
    | Cons (x, xs) -> f (x, foldr f z xs)

let foldl f z =
    | Nil          -> z
    | Cons (x, xs) -> foldl f (f (z, x)) xs

let reverse =
    let rev acc =
        | Nil          -> acc
        | Cons (x, xs) -> rev (Cons (x, acc)) xs
    rev Nil

let filter p =
    | Nil -> Nil
    | Cons (x, xs) ->
        | p x -> Cons (x, filter p xs)
        | _   -> filter p xs

let append =
    | Nil, ys         -> ys
    | Cons (x, xs), ys -> Cons (x, append (xs, ys))

impl Functor (List a) where
    map f =
        | Nil         -> Nil
        | Cons (x, xs) -> Cons (f x, map f xs)

impl Monad (List a) where
    pure x = Cons (x, Nil)
    bind =
        | Nil, _         -> Nil
        | Cons (x, xs), f -> append (f x, bind xs f)

-- 7. Monadic Combinators (Flow Logic)

let then m1 m2 = bind m1 ( \_ -> m2 )

let join mm = bind mm ( \m -> m )

let sequence =
    | Nil -> pure Nil
    | Cons (mx, mxs) -> 
        bind mx ( \x -> 
            bind (sequence mxs) ( \xs -> 
                pure (Cons (x, xs))))

-- 8. Primitive Implementation: Int

impl Ord Int where
    compare =
        | x, y suchThat x < y  -> LT
        | x, y suchThat x == y -> EQ
        | _                    -> GT