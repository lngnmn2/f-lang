mod Prelude where

-- 1. The Core Choice Types (Equational Sums)

type Maybe a =
    | Just a
    | Nothing

type Result a e =
    | Ok a
    | Err e

-- 2. The Universal Comparison Trinity

type Ordering =
    | LT
    | EQ
    | GT

trait Eq a where
    equals : a -> a -> Bool

trait Ord a suchThat a <: Eq a where
    compare : a -> a -> Ordering

-- 3. The Numeric Trinity

trait Num a where
    plus  : a -> a -> a
    minus : a -> a -> a
    times : a -> a -> a

-- 4. Functional Structures (Functor, Applicative, Monad, Alternative)

let id x = x

let const x _ = x

trait Functor f where
    map : (a -> b) -> f a -> f b

trait Applicative f suchThat f <: Functor f where
    pure  : a -> f a
    apply : f (a -> b) -> f a -> f b

trait Monad m suchThat m <: Applicative m where
    bind : m a -> (a -> m b) -> m b

trait Alternative f suchThat f <: Applicative f where
    empty : f a
    alt   : f a -> f a -> f a

-- 5. Instances for Result (Equational Reasoning)

impl Functor (Result a e) where
    map f res = 
        res 
            | Ok x  -> Ok (f x)
            | Err e -> Err e

impl Applicative (Result a e) where
    pure x = Ok x
    apply pf px =
        pf
            | Ok f -> 
                px
                    | Ok x -> Ok (f x)
                    | Err e -> Err e
            | Err e -> \_ -> Err e

impl Monad (Result a e) where
    bind res f =
        res
            | Ok x  -> f x
            | Err e -> Err e

-- 6. The Recursive Trinity (Lists)

type List a =
    | Nil
    | Cons (a, List a)

let head =
    | Nil         -> Nothing
    | Cons (x, _) -> Just x

let tail =
    | Nil          -> Nothing
    | Cons (_, xs) -> Just xs

let null =
    | Nil -> True
    | _   -> False

let length =
    | Nil          -> 0
    | Cons (_, xs) -> plus 1 (length xs)

let foldr f z =
    | Nil          -> z
    | Cons (x, xs) -> f x (foldr f z xs)

let foldl f z =
    | Nil          -> z
    | Cons (x, xs) -> foldl f (f z x) xs

let reverse =
    let rev acc =
        | Nil          -> acc
        | Cons (x, xs) -> rev (Cons (x, acc)) xs
    rev Nil

let filter p =
    | Nil -> Nil
    | Cons (x, xs) ->
        (p x)
            | True  -> Cons (x, filter p xs)
            | False -> filter p xs

let append =
    | Nil -> \ys -> ys
    | Cons (x, xs) -> \ys -> Cons (x, append xs ys)

impl Functor (List a) where
    map f list =
        list
            | Nil         -> Nil
            | Cons (x, xs) -> Cons (f x, map f xs)

impl Applicative (List a) where
    pure x = Cons (x, Nil)
    apply fs list =
        fs
            | Nil -> Nil
            | Cons (f, rest) -> append (map f list) (apply rest list)

impl Monad (List a) where
    bind list f =
        list
            | Nil         -> Nil
            | Cons (x, xs) -> append (f x) (bind xs f)

impl Alternative (List a) where
    empty = Nil
    alt l1 l2 = append l1 l2

-- 7. Monadic Combinators (Flow Logic)

let then m1 m2 = bind m1 ( \_ -> m2 )

let join mm = bind mm ( \m -> m )

let sequence =
    | Nil -> pure Nil
    | Cons (mx, mxs) -> 
        bind mx ( \x -> 
            bind (sequence mxs) ( \xs -> 
                pure (Cons (x, xs))))

-- 8. Primitive Implementation: Int

impl Eq Int where
    equals x y = (x == y)

impl Ord Int where
    compare x y =
        (x < y)
            | True  -> LT
            | False -> 
                (x == y)
                    | True  -> EQ
                    | False -> GT

impl Num Int where
    plus x y = (x + y)
    minus x y = (x - y)
    times x y = (x * y)